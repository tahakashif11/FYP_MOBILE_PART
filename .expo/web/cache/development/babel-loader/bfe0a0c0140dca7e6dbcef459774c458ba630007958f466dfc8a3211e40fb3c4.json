{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _objectWithoutProperties from \"@babel/runtime/helpers/objectWithoutProperties\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/asyncToGenerator\";\nimport _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\nvar _excluded = [\"onContextCreate\", \"onContextRestored\", \"onContextLost\", \"webglContextAttributes\", \"msaaSamples\", \"nativeRef_EXPERIMENTAL\", \"ref\"];\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nimport { CodedError, Platform, UnavailabilityError } from 'expo-modules-core';\nimport invariant from 'invariant';\nimport * as React from 'react';\nimport Dimensions from \"react-native-web/dist/exports/Dimensions\";\nimport Canvas from \"./Canvas\";\nfunction getImageForAsset(asset) {\n  if (asset != null && typeof asset === 'object' && asset !== null && asset.downloadAsync) {\n    var dataURI = asset.localUri || asset.uri || '';\n    var image = new Image();\n    image.src = dataURI;\n    return image;\n  }\n  return asset;\n}\nfunction isOffscreenCanvas(element) {\n  return element && typeof element.convertToBlob === 'function';\n}\nfunction asExpoContext(gl) {\n  gl.endFrameEXP = function glEndFrameEXP() {};\n  if (!gl['_expo_texImage2D']) {\n    gl['_expo_texImage2D'] = gl.texImage2D;\n    gl.texImage2D = function () {\n      for (var _len = arguments.length, props = new Array(_len), _key = 0; _key < _len; _key++) {\n        props[_key] = arguments[_key];\n      }\n      var nextProps = [].concat(props);\n      nextProps.push(getImageForAsset(nextProps.pop()));\n      return gl['_expo_texImage2D'].apply(gl, _toConsumableArray(nextProps));\n    };\n  }\n  if (!gl['_expo_texSubImage2D']) {\n    gl['_expo_texSubImage2D'] = gl.texSubImage2D;\n    gl.texSubImage2D = function () {\n      for (var _len2 = arguments.length, props = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        props[_key2] = arguments[_key2];\n      }\n      var nextProps = [].concat(props);\n      nextProps.push(getImageForAsset(nextProps.pop()));\n      return gl['_expo_texSubImage2D'].apply(gl, _toConsumableArray(nextProps));\n    };\n  }\n  return gl;\n}\nfunction ensureContext(canvas, contextAttributes) {\n  if (!canvas) {\n    throw new CodedError('ERR_GL_INVALID', 'Attempting to use the GL context before it has been created.');\n  }\n  var isIOS = !!navigator.platform && /iPad|iPhone|iPod/.test(navigator.platform);\n  var context = !isIOS && canvas.getContext('webgl2', contextAttributes) || canvas.getContext('webgl', contextAttributes) || canvas.getContext('webgl-experimental', contextAttributes) || canvas.getContext('experimental-webgl', contextAttributes);\n  invariant(context, 'Browser does not support WebGL');\n  return asExpoContext(context);\n}\nfunction getBlobFromWebGLRenderingContext(_x) {\n  return _getBlobFromWebGLRenderingContext.apply(this, arguments);\n}\nfunction _getBlobFromWebGLRenderingContext() {\n  _getBlobFromWebGLRenderingContext = _asyncToGenerator(function* (gl) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    invariant(gl, 'getBlobFromWebGLRenderingContext(): WebGL Rendering Context is not defined');\n    var canvas = gl.canvas;\n    var blob = null;\n    if (typeof canvas.msToBlob === 'function') {\n      blob = yield canvas.msToBlob();\n    } else if (isOffscreenCanvas(canvas)) {\n      blob = yield canvas.convertToBlob({\n        quality: options.compress,\n        type: options.format\n      });\n    } else {\n      blob = yield new Promise(function (resolve) {\n        canvas.toBlob(function (blob) {\n          return resolve(blob);\n        }, options.format, options.compress);\n      });\n    }\n    return {\n      blob: blob,\n      width: canvas.width,\n      height: canvas.height\n    };\n  });\n  return _getBlobFromWebGLRenderingContext.apply(this, arguments);\n}\nexport var GLView = function (_React$Component) {\n  _inherits(GLView, _React$Component);\n  var _super = _createSuper(GLView);\n  function GLView() {\n    var _this;\n    _classCallCheck(this, GLView);\n    for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n      args[_key3] = arguments[_key3];\n    }\n    _this = _super.call.apply(_super, [this].concat(args));\n    _this.onContextLost = function (event) {\n      if (event && event.preventDefault) {\n        event.preventDefault();\n      }\n      _this.gl = undefined;\n      if (typeof _this.props.onContextLost === 'function') {\n        _this.props.onContextLost();\n      }\n    };\n    _this.onContextRestored = function () {\n      _this.gl = undefined;\n      if (_this.getGLContext() == null) {\n        throw new CodedError('ERR_GL_INVALID', 'Failed to restore GL context.');\n      }\n    };\n    _this.setCanvasRef = function (canvas) {\n      _this.canvas = canvas;\n      if (typeof _this.props.nativeRef_EXPERIMENTAL === 'function') {\n        _this.props.nativeRef_EXPERIMENTAL(canvas);\n      }\n      if (_this.canvas) {\n        _this.canvas.addEventListener('webglcontextlost', _this.onContextLost);\n        _this.canvas.addEventListener('webglcontextrestored', _this.onContextRestored);\n        _this.getGLContext();\n      }\n    };\n    return _this;\n  }\n  _createClass(GLView, [{\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      if (this.gl) {\n        var loseContextExt = this.gl.getExtension('WEBGL_lose_context');\n        if (loseContextExt) {\n          loseContextExt.loseContext();\n        }\n        this.gl = undefined;\n      }\n      if (this.canvas) {\n        this.canvas.removeEventListener('webglcontextlost', this.onContextLost);\n        this.canvas.removeEventListener('webglcontextrestored', this.onContextRestored);\n      }\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this$props = this.props,\n        onContextCreate = _this$props.onContextCreate,\n        onContextRestored = _this$props.onContextRestored,\n        onContextLost = _this$props.onContextLost,\n        webglContextAttributes = _this$props.webglContextAttributes,\n        msaaSamples = _this$props.msaaSamples,\n        nativeRef_EXPERIMENTAL = _this$props.nativeRef_EXPERIMENTAL,\n        ref = _this$props.ref,\n        domProps = _objectWithoutProperties(_this$props, _excluded);\n      return React.createElement(Canvas, _objectSpread(_objectSpread({}, domProps), {}, {\n        canvasRef: this.setCanvasRef\n      }));\n    }\n  }, {\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate(prevProps) {\n      var webglContextAttributes = this.props.webglContextAttributes;\n      if (this.canvas && webglContextAttributes !== prevProps.webglContextAttributes) {\n        this.onContextLost(null);\n        this.onContextRestored();\n      }\n    }\n  }, {\n    key: \"getGLContextOrReject\",\n    value: function getGLContextOrReject() {\n      var gl = this.getGLContext();\n      if (!gl) {\n        throw new CodedError('ERR_GL_INVALID', 'Attempting to use the GL context before it has been created.');\n      }\n      return gl;\n    }\n  }, {\n    key: \"getGLContext\",\n    value: function getGLContext() {\n      if (this.gl) return this.gl;\n      if (this.canvas) {\n        this.gl = ensureContext(this.canvas, this.props.webglContextAttributes);\n        if (typeof this.props.onContextCreate === 'function') {\n          this.props.onContextCreate(this.gl);\n        }\n        return this.gl;\n      }\n      return null;\n    }\n  }, {\n    key: \"takeSnapshotAsync\",\n    value: function () {\n      var _takeSnapshotAsync = _asyncToGenerator(function* () {\n        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        if (!GLView.takeSnapshotAsync) {\n          throw new UnavailabilityError('expo-gl', 'takeSnapshotAsync');\n        }\n        var gl = this.getGLContextOrReject();\n        return yield GLView.takeSnapshotAsync(gl, options);\n      });\n      function takeSnapshotAsync() {\n        return _takeSnapshotAsync.apply(this, arguments);\n      }\n      return takeSnapshotAsync;\n    }()\n  }, {\n    key: \"startARSessionAsync\",\n    value: function () {\n      var _startARSessionAsync = _asyncToGenerator(function* () {\n        throw new UnavailabilityError('GLView', 'startARSessionAsync');\n      });\n      function startARSessionAsync() {\n        return _startARSessionAsync.apply(this, arguments);\n      }\n      return startARSessionAsync;\n    }()\n  }, {\n    key: \"createCameraTextureAsync\",\n    value: function () {\n      var _createCameraTextureAsync = _asyncToGenerator(function* () {\n        throw new UnavailabilityError('GLView', 'createCameraTextureAsync');\n      });\n      function createCameraTextureAsync() {\n        return _createCameraTextureAsync.apply(this, arguments);\n      }\n      return createCameraTextureAsync;\n    }()\n  }, {\n    key: \"destroyObjectAsync\",\n    value: function () {\n      var _destroyObjectAsync = _asyncToGenerator(function* (glObject) {\n        throw new UnavailabilityError('GLView', 'destroyObjectAsync');\n      });\n      function destroyObjectAsync(_x2) {\n        return _destroyObjectAsync.apply(this, arguments);\n      }\n      return destroyObjectAsync;\n    }()\n  }], [{\n    key: \"createContextAsync\",\n    value: function () {\n      var _createContextAsync = _asyncToGenerator(function* () {\n        if (!Platform.isDOMAvailable) {\n          return null;\n        }\n        var canvas = document.createElement('canvas');\n        var _Dimensions$get = Dimensions.get('window'),\n          width = _Dimensions$get.width,\n          height = _Dimensions$get.height,\n          scale = _Dimensions$get.scale;\n        canvas.width = width * scale;\n        canvas.height = height * scale;\n        return ensureContext(canvas);\n      });\n      function createContextAsync() {\n        return _createContextAsync.apply(this, arguments);\n      }\n      return createContextAsync;\n    }()\n  }, {\n    key: \"destroyContextAsync\",\n    value: function () {\n      var _destroyContextAsync = _asyncToGenerator(function* (exgl) {\n        return true;\n      });\n      function destroyContextAsync(_x3) {\n        return _destroyContextAsync.apply(this, arguments);\n      }\n      return destroyContextAsync;\n    }()\n  }, {\n    key: \"takeSnapshotAsync\",\n    value: function () {\n      var _takeSnapshotAsync2 = _asyncToGenerator(function* (gl) {\n        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        var _yield$getBlobFromWeb = yield getBlobFromWebGLRenderingContext(gl, options),\n          blob = _yield$getBlobFromWeb.blob,\n          width = _yield$getBlobFromWeb.width,\n          height = _yield$getBlobFromWeb.height;\n        if (!blob) {\n          throw new CodedError('ERR_GL_SNAPSHOT', 'Failed to save the GL context');\n        }\n        return {\n          uri: blob,\n          localUri: '',\n          width: width,\n          height: height\n        };\n      });\n      function takeSnapshotAsync(_x4) {\n        return _takeSnapshotAsync2.apply(this, arguments);\n      }\n      return takeSnapshotAsync;\n    }()\n  }]);\n  return GLView;\n}(React.Component);","map":{"version":3,"mappings":"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","names":["CodedError","Platform","UnavailabilityError","invariant","React","Canvas","getImageForAsset","asset","downloadAsync","dataURI","localUri","uri","image","Image","src","isOffscreenCanvas","element","convertToBlob","asExpoContext","gl","endFrameEXP","glEndFrameEXP","texImage2D","props","nextProps","push","pop","texSubImage2D","ensureContext","canvas","contextAttributes","isIOS","navigator","platform","test","context","getContext","getBlobFromWebGLRenderingContext","options","blob","msToBlob","quality","compress","type","format","Promise","resolve","toBlob","width","height","GLView","onContextLost","event","preventDefault","undefined","onContextRestored","getGLContext","setCanvasRef","nativeRef_EXPERIMENTAL","addEventListener","loseContextExt","getExtension","loseContext","removeEventListener","onContextCreate","webglContextAttributes","msaaSamples","ref","domProps","canvasRef","prevProps","takeSnapshotAsync","getGLContextOrReject","glObject","isDOMAvailable","document","createElement","Dimensions","get","scale","exgl","Component"],"sources":["C:\\reactag\\newstart3\\node_modules\\expo-gl\\src\\GLView.web.tsx"],"sourcesContent":["import { CodedError, Platform, UnavailabilityError } from 'expo-modules-core';\nimport invariant from 'invariant';\nimport * as React from 'react';\nimport { Dimensions } from 'react-native';\n\nimport Canvas from './Canvas';\nimport { WebGLObject } from './GLView';\nimport {\n  GLViewProps,\n  ExpoWebGLRenderingContext,\n  GLSnapshot,\n  SnapshotOptions,\n  ComponentOrHandle,\n} from './GLView.types';\n\nfunction getImageForAsset(asset: {\n  downloadAsync: () => Promise<any>;\n  uri?: string;\n  localUri?: string;\n}): HTMLImageElement | any {\n  if (asset != null && typeof asset === 'object' && asset !== null && asset.downloadAsync) {\n    const dataURI = asset.localUri || asset.uri || '';\n    const image = new Image();\n    image.src = dataURI;\n    return image;\n  }\n  return asset;\n}\n\nfunction isOffscreenCanvas(element: any): element is OffscreenCanvas {\n  return element && typeof element.convertToBlob === 'function';\n}\n\nfunction asExpoContext(gl: ExpoWebGLRenderingContext): WebGLRenderingContext {\n  gl.endFrameEXP = function glEndFrameEXP(): void {};\n\n  if (!gl['_expo_texImage2D']) {\n    gl['_expo_texImage2D'] = gl.texImage2D;\n    gl.texImage2D = (...props: any[]): any => {\n      const nextProps = [...props];\n      nextProps.push(getImageForAsset(nextProps.pop()));\n      return gl['_expo_texImage2D'](...nextProps);\n    };\n  }\n\n  if (!gl['_expo_texSubImage2D']) {\n    gl['_expo_texSubImage2D'] = gl.texSubImage2D;\n    gl.texSubImage2D = (...props: any[]): any => {\n      const nextProps = [...props];\n      nextProps.push(getImageForAsset(nextProps.pop()));\n      return gl['_expo_texSubImage2D'](...nextProps);\n    };\n  }\n\n  return gl;\n}\n\nfunction ensureContext(\n  canvas?: HTMLCanvasElement,\n  contextAttributes?: WebGLContextAttributes\n): WebGLRenderingContext {\n  if (!canvas) {\n    throw new CodedError(\n      'ERR_GL_INVALID',\n      'Attempting to use the GL context before it has been created.'\n    );\n  }\n\n  // Apple disables WebGL 2.0 and doesn't provide any way to detect if it's disabled.\n  const isIOS = !!navigator.platform && /iPad|iPhone|iPod/.test(navigator.platform);\n\n  const context =\n    (!isIOS && canvas.getContext('webgl2', contextAttributes)) ||\n    canvas.getContext('webgl', contextAttributes) ||\n    canvas.getContext('webgl-experimental', contextAttributes) ||\n    canvas.getContext('experimental-webgl', contextAttributes);\n  invariant(context, 'Browser does not support WebGL');\n  return asExpoContext(context as ExpoWebGLRenderingContext);\n}\n\n// @needsAudit @docsMissing\nexport type GLViewWebProps = GLViewProps & {\n  onContextCreate: (gl: WebGLRenderingContext) => void;\n  onContextRestored?: (gl?: WebGLRenderingContext) => void;\n  onContextLost?: () => void;\n  webglContextAttributes?: WebGLContextAttributes;\n  // type overwrite\n  nativeRef_EXPERIMENTAL?(callback: ComponentOrHandle | HTMLCanvasElement | null);\n};\n\nasync function getBlobFromWebGLRenderingContext(\n  gl: WebGLRenderingContext,\n  options: SnapshotOptions = {}\n): Promise<{ width: number; height: number; blob: Blob | null }> {\n  invariant(gl, 'getBlobFromWebGLRenderingContext(): WebGL Rendering Context is not defined');\n\n  const { canvas } = gl;\n\n  let blob: Blob | null = null;\n\n  if (typeof (canvas as any).msToBlob === 'function') {\n    // @ts-ignore: polyfill: https://stackoverflow.com/a/29815058/4047926\n    blob = await canvas.msToBlob();\n  } else if (isOffscreenCanvas(canvas)) {\n    blob = await canvas.convertToBlob({ quality: options.compress, type: options.format });\n  } else {\n    blob = await new Promise((resolve) => {\n      canvas.toBlob((blob: Blob | null) => resolve(blob), options.format, options.compress);\n    });\n  }\n\n  return {\n    blob,\n    width: canvas.width,\n    height: canvas.height,\n  };\n}\n\nexport class GLView extends React.Component<GLViewWebProps> {\n  canvas?: HTMLCanvasElement;\n\n  gl?: WebGLRenderingContext;\n\n  static async createContextAsync(): Promise<WebGLRenderingContext | null> {\n    if (!Platform.isDOMAvailable) {\n      return null;\n    }\n    const canvas = document.createElement('canvas');\n    const { width, height, scale } = Dimensions.get('window');\n    canvas.width = width * scale;\n    canvas.height = height * scale;\n    return ensureContext(canvas);\n  }\n\n  static async destroyContextAsync(exgl?: WebGLRenderingContext | number): Promise<boolean> {\n    // Do nothing\n    return true;\n  }\n\n  static async takeSnapshotAsync(\n    gl: WebGLRenderingContext,\n    options: SnapshotOptions = {}\n  ): Promise<GLSnapshot> {\n    const { blob, width, height } = await getBlobFromWebGLRenderingContext(gl, options);\n\n    if (!blob) {\n      throw new CodedError('ERR_GL_SNAPSHOT', 'Failed to save the GL context');\n    }\n\n    return {\n      uri: blob,\n      localUri: '',\n      width,\n      height,\n    };\n  }\n\n  componentWillUnmount() {\n    if (this.gl) {\n      const loseContextExt = this.gl.getExtension('WEBGL_lose_context');\n      if (loseContextExt) {\n        loseContextExt.loseContext();\n      }\n      this.gl = undefined;\n    }\n    if (this.canvas) {\n      this.canvas.removeEventListener('webglcontextlost', this.onContextLost);\n      this.canvas.removeEventListener('webglcontextrestored', this.onContextRestored);\n    }\n  }\n\n  render() {\n    const {\n      onContextCreate,\n      onContextRestored,\n      onContextLost,\n      webglContextAttributes,\n      msaaSamples,\n      nativeRef_EXPERIMENTAL,\n      // @ts-ignore: ref does not exist\n      ref,\n      ...domProps\n    } = this.props;\n\n    return <Canvas {...domProps} canvasRef={this.setCanvasRef} />;\n  }\n\n  componentDidUpdate(prevProps) {\n    const { webglContextAttributes } = this.props;\n    if (this.canvas && webglContextAttributes !== prevProps.webglContextAttributes) {\n      this.onContextLost(null);\n      this.onContextRestored();\n    }\n  }\n\n  private getGLContextOrReject(): WebGLRenderingContext {\n    const gl = this.getGLContext();\n    if (!gl) {\n      throw new CodedError(\n        'ERR_GL_INVALID',\n        'Attempting to use the GL context before it has been created.'\n      );\n    }\n    return gl;\n  }\n\n  private onContextLost = (event: Event | null): void => {\n    if (event && event.preventDefault) {\n      event.preventDefault();\n    }\n    this.gl = undefined;\n\n    if (typeof this.props.onContextLost === 'function') {\n      this.props.onContextLost();\n    }\n  };\n\n  private onContextRestored = (): void => {\n    this.gl = undefined;\n    if (this.getGLContext() == null) {\n      throw new CodedError('ERR_GL_INVALID', 'Failed to restore GL context.');\n    }\n  };\n\n  private getGLContext(): WebGLRenderingContext | null {\n    if (this.gl) return this.gl;\n\n    if (this.canvas) {\n      this.gl = ensureContext(this.canvas, this.props.webglContextAttributes);\n      if (typeof this.props.onContextCreate === 'function') {\n        this.props.onContextCreate(this.gl);\n      }\n      return this.gl;\n    }\n    return null;\n  }\n\n  private setCanvasRef = (canvas: HTMLCanvasElement): void => {\n    this.canvas = canvas;\n\n    if (typeof this.props.nativeRef_EXPERIMENTAL === 'function') {\n      this.props.nativeRef_EXPERIMENTAL(canvas);\n    }\n\n    if (this.canvas) {\n      this.canvas.addEventListener('webglcontextlost', this.onContextLost);\n      this.canvas.addEventListener('webglcontextrestored', this.onContextRestored);\n\n      this.getGLContext();\n    }\n  };\n\n  public async takeSnapshotAsync(options: SnapshotOptions = {}): Promise<GLSnapshot> {\n    if (!GLView.takeSnapshotAsync) {\n      throw new UnavailabilityError('expo-gl', 'takeSnapshotAsync');\n    }\n\n    const gl = this.getGLContextOrReject();\n    return await GLView.takeSnapshotAsync(gl, options);\n  }\n\n  public async startARSessionAsync(): Promise<void> {\n    throw new UnavailabilityError('GLView', 'startARSessionAsync');\n  }\n\n  public async createCameraTextureAsync(): Promise<void> {\n    throw new UnavailabilityError('GLView', 'createCameraTextureAsync');\n  }\n\n  public async destroyObjectAsync(glObject: WebGLObject): Promise<void> {\n    throw new UnavailabilityError('GLView', 'destroyObjectAsync');\n  }\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}